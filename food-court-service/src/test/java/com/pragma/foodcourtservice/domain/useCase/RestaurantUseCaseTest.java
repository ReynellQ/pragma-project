package com.pragma.foodcourtservice.domain.useCase;

import com.pragma.foodcourtservice.RestaurantData;
import com.pragma.foodcourtservice.UserData;
import com.pragma.foodcourtservice.domain.api.IPersistentLoggedUser;
import com.pragma.foodcourtservice.domain.api.IRestaurantServicePort;
import com.pragma.foodcourtservice.domain.api.IRestaurantValidator;
import com.pragma.foodcourtservice.domain.exception.IncorrectDataException;
import com.pragma.foodcourtservice.domain.exception.NotAllowedRestaurantException;
import com.pragma.foodcourtservice.domain.exception.NotAnOwnerException;
import com.pragma.foodcourtservice.domain.exception.RestaurantNotFoundException;
import com.pragma.foodcourtservice.domain.spi.IRestaurantPersistencePort;
import com.pragma.foodcourtservice.domain.spi.IUserMicroServiceClientPort;
import com.pragma.foodcourtservice.infrastructure.exception.UserNotFoundException;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.springframework.boot.test.context.SpringBootTest;

import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.Mockito.*;

@SpringBootTest
class RestaurantUseCaseTest {

    IUserMicroServiceClientPort userMicroServiceClientPort;
    IRestaurantValidator restaurantValidator;
    IRestaurantPersistencePort restaurantPersistencePort;
    IPersistentLoggedUser persistentLoggedUser;
    IRestaurantServicePort restaurantServicePort;


    @BeforeEach
    void setUp(){
        restaurantPersistencePort = mock(IRestaurantPersistencePort.class);
        restaurantValidator = mock(IRestaurantValidator.class);
        userMicroServiceClientPort = mock(IUserMicroServiceClientPort.class);
        persistentLoggedUser = mock(IPersistentLoggedUser.class);
        restaurantServicePort = new RestaurantUseCase(restaurantPersistencePort, restaurantValidator,
                userMicroServiceClientPort, persistentLoggedUser);

        //mock data
        setUpMockValidation();
        setUpClient();

    }

    private void setUpClient() {
        when(userMicroServiceClientPort.getUserByEmail(RestaurantData.OWNER_001.getEmail()))
                .thenReturn(RestaurantData.OWNER_001);
        when(userMicroServiceClientPort.getUserByEmail(RestaurantData.NOT_A_OWNER.getEmail()))
                .thenReturn(RestaurantData.NOT_A_OWNER);
        when(userMicroServiceClientPort.getUserByEmail(UserData.NON_INSERTED_USER_001.getEmail()))
                .thenThrow(new UserNotFoundException());
    }

    private void setUpMockValidation() {
        when(restaurantValidator.validateOwner(RestaurantData.OWNER_001)).thenReturn(true);
        when(restaurantValidator.validateOwner(RestaurantData.OWNER_002)).thenReturn(true);
        when(restaurantValidator.validateOwner(RestaurantData.NOT_A_OWNER)).thenReturn(false);
        when(restaurantValidator.validateName(RestaurantData.NON_INSERTED_RESTAURANT.getName()))
                .thenReturn(true);
        when(restaurantValidator.validateName(RestaurantData.NON_VALID_RESTAURANT.getName()))
                .thenReturn(false);
        when(restaurantValidator.validatePhone(RestaurantData.NON_INSERTED_RESTAURANT.getPhone()))
                .thenReturn(true);
        when(restaurantValidator.validateName(RestaurantData.NON_VALID_RESTAURANT.getPhone()))
                .thenReturn(false);
    }
    @Test
    void saveRestaurant() {
        when(persistentLoggedUser.getLoggedUser())
                .thenReturn(RestaurantData.OWNER_001);
        assertDoesNotThrow( //Saves correctly
                ()->restaurantServicePort.saveRestaurant(RestaurantData.NON_INSERTED_RESTAURANT)
        );
        //Logged with a user that isn't a owner
        //TODO mock the bad owner, but technically it cannot happen for the auth service.
        when(persistentLoggedUser.getLoggedUser())
                .thenReturn(RestaurantData.EMPLOYEE);
        assertThrows(NotAnOwnerException.class, //Throws the exception for not being a owner
                () -> restaurantServicePort.saveRestaurant(RestaurantData.NON_INSERTED_RESTAURANT)
        );
        //Saves a restaurant with bad data
        when(persistentLoggedUser.getLoggedUser())
                .thenReturn(RestaurantData.OWNER_002);
        assertThrows(IncorrectDataException.class,
                () -> restaurantServicePort.saveRestaurant(RestaurantData.NON_VALID_RESTAURANT)
        );
    }

    @Test
    void listAllAlphabeticallyRestaurantsPaginated() {
    }

    @Test
    void saveAnEmployeeOfARestaurant() {
        goodSaveOfEmployee();
        savingAndDoesntExistsTheRestaurant();
        savingAndTheOwnerDoesntOwnTheRestaurant();
        badDataOfEmployee();
    }

    /**
     * The employee has bad data. This validation it's done by the user microservice in the insertion, for this the
     * exception is generated by the userClientPort.
     */
    private void badDataOfEmployee() {
        when(persistentLoggedUser.getLoggedUser())
                .thenReturn(RestaurantData.OWNER_001);
        when(restaurantPersistencePort.getRestaurant(RestaurantData.RESTAURANT_001.getId()))
                .thenReturn(RestaurantData.RESTAURANT_001);
        doAnswer(
                invocation ->
                        when(userMicroServiceClientPort.getUserByPersonalId(RestaurantData.EMPLOYEE.getPersonalId()))
                                .thenReturn(RestaurantData.EMPLOYEE)
        ).when(userMicroServiceClientPort)
                .saveAnEmployee(RestaurantData.EMPLOYEE);
        doThrow(new IncorrectDataException())
                .when(userMicroServiceClientPort).saveAnEmployee(UserData.USER_WITH_INCORRECT_EMAIL);
        assertThrows(
                IncorrectDataException.class,
                ()->restaurantServicePort.saveAnEmployeeOfARestaurant(
                        UserData.USER_WITH_INCORRECT_EMAIL,
                        RestaurantData.RESTAURANT_001.getId())
        );
    }

    private void savingAndTheOwnerDoesntOwnTheRestaurant() {
        when(persistentLoggedUser.getLoggedUser())
                .thenReturn(RestaurantData.OWNER_002);
        when(restaurantPersistencePort.getRestaurant(RestaurantData.RESTAURANT_001.getId()))
                .thenReturn(RestaurantData.RESTAURANT_001);
        doAnswer(
                invocation ->
                        when(userMicroServiceClientPort.getUserByPersonalId(RestaurantData.EMPLOYEE.getPersonalId()))
                                .thenReturn(RestaurantData.EMPLOYEE)
        ).when(userMicroServiceClientPort)
                .saveAnEmployee(RestaurantData.EMPLOYEE);
        assertThrows(
                NotAllowedRestaurantException.class,
                ()->restaurantServicePort.saveAnEmployeeOfARestaurant(
                        RestaurantData.EMPLOYEE,
                        RestaurantData.RESTAURANT_001.getId())
        );
    }

    private void savingAndDoesntExistsTheRestaurant() {
        when(persistentLoggedUser.getLoggedUser())
                .thenReturn(RestaurantData.OWNER_001);
        when(restaurantPersistencePort.getRestaurant(RestaurantData.NON_INSERTED_RESTAURANT.getId()))
                .thenThrow(new RestaurantNotFoundException());
        doAnswer(
                invocation ->
                        when(userMicroServiceClientPort.getUserByPersonalId(RestaurantData.EMPLOYEE.getPersonalId()))
                                .thenReturn(RestaurantData.EMPLOYEE)
        ).when(userMicroServiceClientPort)
                .saveAnEmployee(RestaurantData.EMPLOYEE);
        assertThrows(
                RestaurantNotFoundException.class,
                ()->restaurantServicePort.saveAnEmployeeOfARestaurant(
                        RestaurantData.EMPLOYEE,
                        RestaurantData.NON_INSERTED_RESTAURANT.getId())
        );
    }

    private void goodSaveOfEmployee() {
        when(persistentLoggedUser.getLoggedUser())
                .thenReturn(RestaurantData.OWNER_001);
        when(restaurantPersistencePort.getRestaurant(RestaurantData.RESTAURANT_001.getId()))
                .thenReturn(RestaurantData.RESTAURANT_001);
        doAnswer(
                invocation ->
                    when(userMicroServiceClientPort.getUserByPersonalId(RestaurantData.EMPLOYEE.getPersonalId()))
                            .thenReturn(RestaurantData.EMPLOYEE)
        ).when(userMicroServiceClientPort)
                .saveAnEmployee(RestaurantData.EMPLOYEE);
        assertDoesNotThrow( ()->restaurantServicePort.saveAnEmployeeOfARestaurant(RestaurantData.EMPLOYEE,
                RestaurantData.RESTAURANT_001.getId()));




    }
}